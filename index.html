<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Differentiable Rasterization</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="docs/github.min.css" />
  <link rel="stylesheet" href="docs/tufte.css" />
  <link rel="stylesheet" href="docs/extra.css" />
  <script src="/usr/share/javascript/mathjax/tex-mml-chtml.js" type="text/javascript"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/atom-one-light.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
  <script>hljs.highlightAll()</script>
</head>
<body>
<h1 id="a-tour-of-differentiable-rasterization">A Tour of Differentiable Rasterization</h1>
<p>By <a href="https://x.com/srush_nlp">Sasha Rush</a></p>
<p>Built with <a href="https://github.com/chalk-diagrams/">Chalk</a> developed by <a href="https://doneata.bitbucket.io/">Dan Oneață</a></p>
<p>Inspired by</p>
<ul>
<li><a href="https://cseweb.ucsd.edu/~tzli/diffvg/">Differentiable Vector Graphics Rasterization for Editing and Learning</a></li>
<li><a href="http://kunzhou.net/zjugaps/pathrendering/GPUpathrendering.pdf">Efficient GPU Path Rendering Using Scanline Rasterization</a></li>
<li><a href="https://core.ac.uk/download/pdf/76383233.pdf">Monoids: Theme and Variations</a></li>
<li><a href="https://jax.readthedocs.io/en/latest/">JAX: High-Performance Array Computing</a></li>
</ul>
<p>Given a program that produces a vector representation of an image (think SVG), <em>rasterization</em> turns it into a pixel representation (think PNG). If we have a image we can see how close we got.</p>
<p><span class="math display">\[\begin{align*}
  \text{vector} &amp;= \text{program}(x) \\
  \text{image} &amp;= \text{rasterizer}(x) \\
  {\cal L}(\text{png}, \text{target}) &amp;= \| \text{image} - \text{target} \| \\
\end{align*}\]</span></p>
<p>Unfortunately this process is not inherently differentiable. Moreover, it doesn’t easily run in modern deep learning frameworks like Jax or PyTorch. The goal of this post is to walk through this calculation.</p>
<p><span class="math display">\[\text{Goal:}   \frac{d {\cal L}}{dx} = \frac{d {\cal L}}{d\ \text{image}} \frac{d\ {\text{image}}}{d\ \text{vector}} \frac{d\ \text{vector}}{dx}\]</span></p>
<p>To make this all more tangible, say we have a target image and a program that can draw ellipses based on their locations, size, and rotation. Differentiable rasterization would let us use gradient descent to adjust the parameters <span class="math inline">\(x\)</span> to match the image.</p>
<script src="https://unpkg.com/freezeframe/dist/freezeframe.min.js"></script>
<div>
<img src="smiley3.webp" width="40%">
<div style="width:40%; float:right">
<img class="freezeframe" id="smiley" src="smiley1.gif" width="40%">
</div>
</div>
<script>
new Freezeframe({selector: '#smiley', overlay:true});
</script>
<p>The goal of this blog is not about computer graphics. Caveat: I know nothing about computer graphics.</p>
<p>The goal of this blog is to learn about differentiable programming in realistic settings. If autodiff + vectorization is the future, then it is important to be able to write hard programs in a differentiable style (beyond just another boring Transformer).</p>
<p>The blog is in 5 parts. It assumes no graphics knowledge, but does use a lot of Jax/NumPy tricks. The target audience is someone with a lot of ML experience who wants to branch out into some more complex uses of derivatives.</p>
<p>You can also just look at the cool pictures!</p>
<ul>
<li><a href="#section-1-transforms-arcs-paths">Section 1: Transforms, Arcs, Paths</a></li>
<li><a href="#section-2-jax-x-graphics">Section 2: Jax x Graphics</a></li>
<li><a href="section-3-tracing">Section 3: Tracing</a></li>
<li><a href="section-4-vector---image">Section 4: Vector -&gt; Image</a></li>
<li><a href="section-5-differentiable-rasterization">Section 5: Differentiable Rasterization</a></li>
</ul>
<h2 id="section-1-transforms-arcs-paths">Section 1: Transforms, Arcs, Paths</h2>
<p>The first stage is to get to a vector graphics specification. That is,</p>
<p><span class="math display">\[\begin{align*}
  \text{vector} &amp;= \text{program}(x) \\
\end{align*}
\]</span></p>
<p>To arrive here, we need to convince ourselves that this process is fully differentiable and expressible in Jax. This will also allow us to introduce the basic primitives of vector graphics.</p>
<h3 id="transforms">Transforms</h3>
<p>A <em>transform</em> is an affine function of a 2D point. Given a point <span class="math inline">\((x, y)\)</span>, we produce a point <span class="math inline">\((x&#39;, y&#39;)\)</span> where <span class="math inline">\(x&#39; = a x + b y + c\)</span> and <span class="math inline">\(y&#39; = d x + e y + f\)</span>. This will allow us to mathematically represent intuitive notions of scaling, rotation, and translation.</p>
<p>We can represent these affine functions as a 3x3 matrices. <span class="math display">\[\begin{align*}
\begin{bmatrix} x&#39; \\ y&#39; \\ 1 \end{bmatrix} &amp;= \begin{bmatrix} a &amp; b &amp; c \\ d &amp; e &amp; f \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix} \\
\end{align*}\]</span> The key trick being to represent 2D points in 3D with a fixed 1 in the last position. We can the apply transforms to points, lines, shapes, or other transforms etc. As these are standard matrix operations, they naturally have meaningful derivatives, which autodiff can provide for us.</p>
<p>We start by applying them to a simple line.</p>
<pre class="python"><code>line = arc_seg(V2(1, 1), 1e-3).stroke()</code></pre>
<p>Translations have an identity scaling and use the last column for the offet. We show the transform on the right side.</p>
<pre class="python"><code>def translate(t: float):
    &quot;t is a float between 0 and 1&quot;
    affine = tx.translation(V2(0, t))
    return line.apply_transform(affine), show_affine(affine)


animate(translate)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.1.gif" id='ff1'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff1'  
});
</script>
<p>Scaling uses the diagonal.</p>
<pre class="python"><code>def scale(t):
    affine = tx.scale(t)
    return line.apply_transform(affine), show_affine(affine)


animate(scale)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.2.gif" id='ff2'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff2'  
});
</script>
<p>Rotation uses the off-diagonal.</p>
<pre class="python"><code>def rotate(t):
    affine = tx.rotation(t * 2 * np.pi)
    return line.apply_transform(affine), show_affine(affine)


animate(rotate)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.3.gif" id='ff3'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff3'  
});
</script>
<p>We overload the + operator to represent composition. Here two lines are combined in a single image. The first is rotated and the second is rotated in the opposite direction using the inverse of the transform.</p>
<pre class="python"><code>def cat(t):
    affine = tx.rotation(t * 2 * np.pi)
    affine2 = tx.inv(affine)
    return line.apply_transform(affine) + line.apply_transform(affine2), show_affine(
        affine
    ) | show_affine(affine2)


animate(cat)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.4.gif" id='ff4'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff4'  
});
</script>
<p>Colors are also represented as vectors and can be combined.</p>
<p><span class="math display">\[ \text{color} = \begin{bmatrix} r \\ g \\ b \end{bmatrix}\]</span></p>
<pre class="python"><code>def color_line(t):
    red = to_color(&quot;red&quot;)
    blue = to_color(&quot;blue&quot;)
    color = t * red + (1 - t) * blue
    return line.line_color(color), show_color(color)


animate(color_line)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.5.gif" id='ff5'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff5'  
});
</script>
<h3 id="arcs-and-shapes">Arcs and Shapes</h3>
<p>The only drawing primitive we will provide is an <em>arc</em>. Arcs are created by providing a vector offset and the bend height. Here’s what that does.</p>
<pre class="python"><code>def arc(t):
    v = V2(1, 0)
    a_s = arc_seg(v, t)
    return a_s.stroke()


animate(arc)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.6.gif" id='ff6'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff6'  
});
</script>
<p>These values are converted internally to an implicit circle using some (differentiable) high-school trigonometry. We store the radius of this circle, the start angle, and the offset. Here is what these arcs look like by composing the arc and the internal circle representation.</p>
<pre class="python"><code>def arc(t):
    v = V2(1, 0)
    a_s = arc_seg(v, t)
    return a_s.stroke().line_width(2) + show_arc(a_s).stroke().line_width(0.1)


animate(arc, lw=False)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.7.gif" id='ff7'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff7'  
});
</script>
<p>We can chain arcs together, again using the overloaded <code>+</code> operator to make a <em>path</em>. Paths can be closed to indicate a filled shape. Filled paths made with chained arcs will be the core element we work with.</p>
<p>(Note chaining must be done before calling <code>stroke()</code> since <code>+</code> is also used for composition.)</p>
<pre class="python"><code>def closed(t):
    v = V2(1, 0)
    return (arc_seg(v, t) + arc_seg(-v, -0.2)).close().stroke()


animate(closed)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.8.gif" id='ff8'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff8'  
});
</script>
<p>We can put everything together to create a circle function.</p>
<pre class="python"><code>def circle_at(p, r):
    &quot;Draw a circle at `p` with radius `r`&quot;
    # Draw a circle with radius 1 centered at (0, 1)
    circle = (arc_seg(V2(0, 2), 1) + arc_seg(V2(0, -2), 1)).close().stroke()
    # Move the circle to p and scale to radius r
    affine = tx.translation(p) @ tx.scale(r) @ tx.translation(V2(0, -1))
    return circle.apply_transform(affine)


def draw_circle(t):
    return circle_at(t, t)


animate(draw_circle)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.9.gif" id='ff9'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff9'  
});
</script>
<h2 id="section-2-jax-x-graphics">Section 2: Jax x Graphics</h2>
<p>Since the math underlying these primitives is in NumPy, we can use Jax to work with them. The key requirement is that the paths be made up of NumPy arrays and are composed with Jax <a href="https://jax.readthedocs.io/en/latest/pytrees.html">PyTrees</a>.</p>
<p>The downside of Jax is that we will not be able to use a lot of standard python functions, and will have to write everything in a strick functional style without <code>if's</code>. This will make later things harder.</p>
<p>But there are several really nice benefits that Jax provides. The first is that we can use Jax’s <a href="https://jax.readthedocs.io/en/latest/_autosummary/jax.vmap.html">vmap</a> function transform to create many paths at once. For example here we are using <code>vmap</code> to create 10 circles.</p>
<p>(Note as well that we are using shortcut <code>scale_x</code> which creates and applies a scaling affine transform.)</p>
<pre class="python"><code>def draw(t):
    @jax.vmap
    def multi(i):
        return circle_at(P2(0, 0), (0.05 * i + t)).scale_x(1.2).fill_opacity(0)

    return multi(np.arange(1, 10))


animate(draw)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.10.gif" id='ff10'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff10'  
});
</script>
<p>Jax transforms take a little longer to startup, but they automatically let us scale to some very complex figures. Here we are creating 100 circles.</p>
<pre class="python"><code>def draw(t):
    red = to_color(&quot;red&quot;)
    green = to_color(&quot;green&quot;)

    @jax.vmap
    def multi(i):
        i_s = i / 100
        s = (0.05 * i) / 2
        rot = tx.rotation(i * t + i)
        return (
            rectangle(s, s)
            .fill_color(i_s * red + (1 - i_s) * green)
            .line_width(0)
            .apply_transform(rot)
        )

    return multi(np.arange(100, 1, -1))


animate(draw, lw=False, steps=200, rate=5)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.11.gif" id='ff11'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff11'  
});
</script>
<p>This one is a really neat pinwheel effect. Here we are using <code>vmap</code> with multiple arguments. Later we will use <code>vmap</code> with a whole tree of parameters.</p>
<pre class="python"><code>T = 100


def multi(t):
    r, g = to_color(&quot;red&quot;), to_color(&quot;green&quot;)

    @jax.vmap
    def draw(x, y):
        t2 = (x + y + t) % 1
        t2 = np.maximum(t2, 1 - t2)
        return (
            circle_at(P2(x, y), t2 / 10 - 0.2)
            .fill_color(t2 / 2 * r + 2 * (1 - t2) * g)
            .translate(-0.5, -0.5)
            .scale(2)
            .line_width(0)
        )

    return draw((np.arange(T) // 10) / 10, (np.arange(T) % 10) / 10)


animate(jax.jit(multi), steps=10, lw=False)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.12.gif" id='ff12'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff12'  
});
</script>
<p>The other core benefit of having Jax is to be able to differentiate functions. Since we are able to take derivatives of all our functions we can use gradient descent to optimize for arbitrary properties. We’ll introduce a function <code>opt</code> that uses Adam to optimize and draw an arbitrary function.</p>
<pre class="python"><code>def L2(x):
    return (x * x).sum(-1)


def find_point(target, x):
    return L2(target - x).sum(), (
        grid
        + circle_at(target, 0.1).fill_color(&quot;red&quot;)
        + circle_at(x, 0.1).fill_color(&quot;blue&quot;)
    ).layout(500)


# Use partial to specify the target. Optimize over x.
opt(P2(0, 0), partial(find_point, P2(0.5, 0.5)), steps=100, rate=0.1)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.13.gif" id='ff13'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff13'  
});
</script>
<p>Okay that one was pretty simple. Let’s try something a little more complex that uses all our tricks so far.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Force-directed_graph_drawing">force-directed graph</a> is a way to layout a graph in a visually pleasing way in 2D space. The main idea is to apply (and optimize for) physical forces over the nodes and edges.</p>
<p>In our example code we will use three forces. A spring along edges, repulsion between all nodes, and a weak gravity towards the center of the graph.</p>
<pre class="python"><code>@jax.jit
def force_directed(x, edges, a=1 / 20, b=1 / 10, c=50, spring=0.04):
    # Draw nodes
    size = x.shape[0]
    nodes = np.arange(size)
    color = np.stack([to_color(c) for c in Color(&quot;red&quot;).range_to(&quot;blue&quot;, size)])

    @jax.vmap
    def dots(p, i, color):
        d = circle(0.1).translate(p[0], p[1]).fill_color(color)
        return d, np.abs(x).sum()

    out, gravity = dots(x, np.arange(size), color)

    @jax.vmap
    def connect(inp, out):
        a, b = x[inp], x[out]
        # `make_path`` is a helper around `seg`.
        return make_path([(a[0], a[1]), (b[0] + eps, b[1] + eps)]), L2(a - b)

    lines, tension = connect(nodes, edges)

    # Style
    out = out.with_envelope(empty()).line_width(2)
    # `with_envelope` speeds up rendering, `rectangle` is a helper for paths
    out = (
        rectangle(5, 5).fill_color(&quot;white&quot;)
        + lines.with_envelope(empty()).line_width(1)
        + out
    )

    # Forces
    # Repulse everyone but ourselves
    repulse = ((1 / (1e-3 + L2(x[:, None] - x))) * (1 - np.eye(size))).sum()

    score = a * gravity.sum() + b * repulse + c * L2(tension - spring)

    return score, out.layout(500)</code></pre>
<p>Make a graph of little clusters</p>
<pre class="python"><code>size = 50
around = 5
groups = size // around
matrix = jax.random.uniform(jax.random.PRNGKey(0), (size, 2)) * 2 - 1
edges = (np.arange(size) // around) * around
opt(matrix, partial(force_directed, edges=edges), steps=500)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.14.gif" id='ff14'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff14'  
});
</script>
<p>Make a graph of little rings</p>
<pre class="python"><code>size = 100
matrix = jax.random.uniform(jax.random.PRNGKey(0), (size, 2)) * 2 - 1
edges = (np.arange(size) + 1) % 10 + (np.arange(size) // 10) * 10
opt(matrix, partial(force_directed, edges=edges), steps=500)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.15.gif" id='ff15'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff15'  
});
</script>
<h2 id="section-3-tracing">Section 3: Tracing</h2>
<p>Now we are going to put everything together by combining optimization and graphics. The key idea is that if we use Jax to layout paths, we can optimize based on the result of that layout. To do this, we need a differentiable way to check where different paths ended up.</p>
<p>We represent this information through the <em>trace</em> function for each path. A trace function takes in a point and a direction (a <em>ray</em>) and returns a set of lengths at which that ray hits the path. That is sufficient information to tell us the specific points of intersection.</p>
<p>This is more clear in an animation.</p>
<pre class="python"><code>def ray(t, shape, pt, v):
    ray = seg(v).stroke().scale(t + 0.1).translate_by(pt) + circle_at(pt, 0.1)
    trace = shape.get_trace()
    # Length to hit shape.
    s, m = trace(pt, v)
    return shape + ray + circle_at(np.max(s) * v + pt, 0.1).fill_color(&quot;red&quot;)


shape = circle_at(P2(0, 0), 1).fill_color(&quot;white&quot;)
animate(partial(ray, shape=shape, pt=P2(0.2, -0.1), v=V2(2, 1)))</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.16.gif" id='ff16'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff16'  
});
</script>
<p>Recall from above that arcs are just angles on a unit circle transformed by <span class="math inline">\(A\)</span>. This implies that the trace can be calculated by applying the inverse of this transform <span class="math inline">\(A^{-1}\)</span> to the ray, and calcuting its distance to the unit circle.</p>
<p>The formula for this calculation is to find a common point on the ray and the unit circle. Let’s do some algebra. Let <span class="math inline">\(r\)</span> be the length of the trace.</p>
<p><span class="math display">\[ \begin{align*}
x = v_x r + p_x &amp; y = v_y r + p_y \\
x^2 + y^2 &amp;= 1 \\
\Rightarrow&amp; (v_x^2 + v_y^2) r^2 + 2(v_x p_x + v_y p_y) r  + (p_x^2 + p_y^2 - 1) = 0 \\
\Rightarrow&amp; \| v \| r^2 + 2 p \cdot v r  + (\| p \| - 1) = 0 \\
\end{align*}
\]</span></p>
<p>We then apply the quadratic formula to solve for roots.</p>
<p><span class="math display">\[\begin{align*}
\frac{-b \pm \sqrt{b^2 - 4a c}}{2a}
\end{align*}\]</span></p>
<p>The two values correspond to the two possible intersections. Negative values correspond to missing the circle. Once we find the value, we can also compute the angle of the intersection <span class="math inline">\(r (p + v)\)</span> and check if it is within the arc.</p>
<p>We can use this with any point, shape, and vector.</p>
<pre class="python"><code>shape = arc_seg(V2(2, 0), 0.5).stroke().translate(-1, 0)
animate(partial(ray, shape=shape, pt=P2(0.2, 0.3), v=V2(1, -1)))</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.17.gif" id='ff17'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff17'  
});
</script>
<p>Note that there may be multiple intersections between the ray and the shape. This means trace needs to return a set of values. Working with sets is difficult in languages like Jax because array size needs to remain constant in repeated calls to a function. To handle this issue we return a fixed size array with a mask.</p>
<p>Here’s an example that shows multiple intersections, as well as use of complex affine transformations.</p>
<pre class="python"><code>def crescent():
    part1 = arc_seg(unit_x, 0.5)
    part2 = arc_seg(-unit_x, -0.2)
    return part1, part2, (part1 + part2).close().stroke()


def trace(d, t, px=0, py=0):
    # Place the ray
    d = d.center_xy()
    affine = tx.rotation(t * 2 * np.pi)
    pt, v = P2(0, 1.5), V2(0, -1.5)
    pt, v = affine @ pt + V2(px, py), affine @ v

    # Trace gives distance to arcs
    trace = d.get_trace()
    p, m = trace(pt, v)

    # Draw
    line = seg(V2(0, -1 / 2)).stroke()
    out = (
        d
        + line.apply_transform(tx.translation(pt) @ affine)
        + circle_at(pt, 0.1).fill_color(&quot;white&quot;)
    )
    out = out.line_width(2)
    for i in range(p.shape[1]):
        out = out + circle_at(p[:, i] * v + pt, 0.1).fill_color(&quot;red&quot;).fill_opacity(
            m[:, i]
        ).line_width(m[:, i])
    return out


animate(partial(trace, crescent()[2]), lw=False)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.18.gif" id='ff18'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff18'  
});
</script>
<p>Internally, we are storing all the arcs that make up a path. each of these is reset to the unit circle where we then apply a ray-circle formula to find possible intersections.</p>
<p>Arc 1</p>
<pre class="python"><code>animate(partial(trace, crescent()[0].stroke()), lw=False)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.19.gif" id='ff19'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff19'  
});
</script>
<p>Arc 2.</p>
<pre class="python"><code>animate(partial(trace, crescent()[1].stroke(), py=-0.2), lw=False)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.20.gif" id='ff20'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff20'  
});
</script>
<p>Now here’s the cool part. Because all of these traces are computed with jax using differentiable transformations, we can combine them with our generic gradient optimizer. Here we set up a function that given any shape and ray will compute and draw the trace.</p>
<pre class="python"><code>def draw_trace(d, pt, v):
    # Trace the image
    trace = d.get_trace()
    p, m = trace(pt, v)

    # Draw the raw and trace.
    line = seg(V2(0, -1 / 2)).stroke()
    out = d + seg(v).stroke().translate_by(pt) + circle_at(pt, 0.1).fill_color(&quot;white&quot;)
    pos = (1 - m[:, :])[..., None, None] * 100 + p[..., None, None] * v + pt
    out = out + Path.from_points([pos[:, 0], pos[:, 1] + eps]).stroke().line_color(
        &quot;white&quot;
    ).line_width(10)
    for i in range(2):
        out = out + circle_at(pos[:, i], 0.1).fill_color(&quot;red&quot;)
    return out, p</code></pre>
<p>Using this function, we can then optimize for trace properties. Here search for the outer angle that leads to the largest trace. this can just be done with the standard optimizer from the last section.</p>
<pre class="python"><code>def trace_width(d, t):
    d = d.center_xy()
    # Outer satelite
    affine = tx.rotation(t)
    pt, v = affine @ P2(0, 1.5), affine @ V2(0, -1.5)

    # Trace the image
    out, p = draw_trace(d, pt, v)
    score = p[:, 1] - p[:, 0]
    return score.sum(), (grid + out.line_width(1)).layout(500)


opt(np.array(np.pi / 4.0), partial(trace_width, crescent()[2]), rate=0.05)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.21.gif" id='ff21'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff21'  
});
</script>
<h2 id="section-4-vector---image">Section 4: Vector -&gt; Image</h2>
<p>Now that we have a trace function, we are going to use it to do rasterization, i.e. converting from vector paths to a visible image, specifical a height <span class="math inline">\(\times\)</span> width <span class="math inline">\(\times\)</span> color array.</p>
<p>Haven’t we been doing this all along though? Well kind of. We have been cheating under the hood and using Cairo an open-source rasterizer. We want to do it ourself.</p>
<p>To do rasterization, we will use a simple <a href=""><em>scanline</em></a> algorithm. The algorithm simply walks down each row one pixel at a time, runs a trace, and then fills in the middles. To make things even simpler we will use an <em>even-odd</em> rule where we consider all pixels after an <em>odd</em> intersection to be inside the path.</p>
<pre class="python"><code>def scanline(t, shape):
    return draw_trace(shape, P2(1, 1 + 10 * t), V2(1, 0))[0]


shape = crescent()[2].scale(7).rotate(70).translate(6, 8).fill_color(&quot;orange&quot;)
animate(partial(scanline, shape=shape), grid=hgrid, steps=100)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.22.gif" id='ff22'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff22'  
});
</script>
<p>Here’s the critical rasterization code. This function produces 1 row of the image given the trace for that row. Its job:</p>
<ul>
<li>Determine inside pixels.</li>
<li>Determine boundary pixels</li>
<li>Be as fast as possible</li>
</ul>
<p>Here’s how you would do this in simple python.</p>
<pre class="python"><code>for j in columns:
   even = True
   for mask, split in zip(mask, splits):
       if not mask:
           splits_int[floor(split)] = split
   if j in splits_int:
       split = split_int[j]
       if even:
           scene[j] = 1 - (split - j)
       else:
           scene[j] = split - j
       even = not even
   else:
       if odd:
           scene[j] = 1</code></pre>
<p>It’s a relatively simple algorithm, but remember we can’t use conditionals, mutation, or dictionaries in Jax. And we want it to run in parallel!</p>
<p>We will instead use an approach of scanline rendering targeting GPUs. The trick will be to first mark where we cross a boundary and then use a <em>cumulative sum</em> to combine them together. This all can be done in parallel. Here’s the code.</p>
<pre class="python"><code>SIZE = 100
blank = np.ones((SIZE, SIZE, 3))

@jax.jit
@jax.vmap
def render_line(splits, mask):
    # Discretize each split to its pixel cell.
    split_int = np.floor(splits).astype(int)

    # `np.where`` will be our if statement replacement.
    # Set `ind` to these values, unless it is masked.
    ind = np.where(mask, split_int, 1000)

    # Create a blank row.
    zero = np.zeros(SIZE)

    # Compute the even / odd position of each split
    # (Assume sorted with masked last)
    loc = np.arange(splits.shape[-1]) % 2

    # Set even-&gt;odd pixels as 1 and odd-&gt;even as 0.
    inout = np.where(loc, -1, 1)
    scene = zero.at[ind].add(inout).at[0].set(0)

    # Run a cumulative sum to fill in inside.
    scene = np.cumsum(scene, axis=-1)

    # Set boundaries based on where pixel fell inside.
    scene = scene.at[ind].set(np.where(loc, 0, 1) - inout * (splits - split_int)).at[0].set(0)

    # If we didn&#39;t end on even, something went wrong.
    return np.where(mask.sum() % 2 == 0, scene, zero)


shape = crescent()[2].scale(70).rotate(70).translate(60, 80).fill_color(&quot;orange&quot;)
plt.imshow(render_line(*shape.get_trace()(P2(0, np.arange(100)), V2(1, 0))))
None</code></pre>
<figure>
<img src="fullblog_files/fullblog_91_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>Nice! 10 lines of code and we have a rasterizer. It works pretty nice off the bat. The main problem though is that it doesn’t yet look as good as Cairo’s version. The textbook issue is that we have <em>aliasing</em>. If you zoom into the edge of our moon you will see jagged little edges.</p>
<p>To make things simple, we’ll apply anti-aliasing on each row independently. This is a 1D simplification but it makes the math much easier.</p>
<p><span class="math display">\[I(x) = \int k(u) f(x- u; \theta) du\]</span></p>
<p>Where <span class="math inline">\(f(x-u)\)</span> is the value of the line our vector image, <span class="math inline">\(k(x)\)</span> is our kernel, and <span class="math inline">\(I(x)\)</span> is our output image. The <em>kernel</em> is just a function that weights the contribution to the pixel based on how far away <span class="math inline">\(u\)</span> is.</p>
<p>We can approximate this integral with Monte-Carlo sampling.</p>
<p><span class="math display">\[ I(x) \approx \frac{1}{N} \sum_i k(u_i) f(x - u_i)  \]</span></p>
<p>Where <span class="math inline">\(u_i\)</span> are <span class="math inline">\(N\)</span> chosen points around <span class="math inline">\(x\)</span>.</p>
<p>We’ll use a triangle kernel where the weight decays linearly from the center. To avoid randomness, we’ll always separate the points in a 1D Line. You can think of this a just applying a 1D convolution to each row of the image.</p>
<pre class="python"><code>kern = 11
samples = np.arange(kern) - (kern // 2)


def kernel(offset):
    off_samples = samples - offset
    kernel = kern - np.abs(off_samples)
    return np.maximum(0, kernel / (kern - np.abs(samples)).sum())

# Allow us to offset the grid
plt.plot(samples, kernel(0), &quot;o-&quot;)
plt.plot(samples - 0.2, kernel(0.2), &quot;o-&quot;)
plt.plot(samples + 0.5, kernel(0.2), &quot;o-&quot;)</code></pre>
<pre><code>[&lt;matplotlib.lines.Line2D at 0x7bb668e7f860&gt;]</code></pre>
<figure>
<img src="fullblog_files/fullblog_100_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<pre class="python"><code>@jax.vmap
def convolve(line):
    k = kernel(0)
    return jax.vmap(lambda s: line[s + samples] @ k)(np.arange(line.shape[0]))


plt.imshow(convolve(render_line(*shape.get_trace()(P2(0, np.arange(100)), V2(1, 0)))))
None</code></pre>
<figure>
<img src="fullblog_files/fullblog_101_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>Now let’s put everything together. There are three steps.</p>
<ol type="1">
<li>Scan the image.</li>
<li>Anti-Alias with a 1D convolution.</li>
<li>Compose the image.</li>
</ol>
<p>We will do it twice once for rows and once for columns.</p>
<pre class="python"><code>directions = list(map(np.stack, [(V2(0, 1), V2(1, 0)), (V2(1, 0), V2(0, 1))]))

@jax.jit
def render_shape(img, s):
    S = np.arange(SIZE)
    trace = s.get_trace()

    def render(img, d):
        pt, v = d
        # 1. Scan
        raster = render_line(*trace(tx.to_point(pt * S[:, None, None]), v))
        # 2. Apply a 1d conv
        raster = convolve(raster)
        # 3. compose
        img = (1 - raster[..., None]) * img + raster[..., None] * s.style.fill_color_
        return np.swapaxes(img, 0, 1), raster

    return jax.lax.scan(render, img, directions)


plt.imshow(render_shape(blank, shape)[0])
None</code></pre>
<figure>
<img src="fullblog_files/fullblog_103_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>We apply the same process for all the paths.</p>
<pre class="python"><code>@jax.vmap
def make_shape(i):
    r, g = to_color(&quot;red&quot;), to_color(&quot;green&quot;)
    return shape.translate(-30 + i * 40, -10 + i * 30).fill_color(r * i + g * (1 - i))

def render_shapes(shapes):
    return jax.lax.scan(render_shape, blank, shapes)[0]

plt.imshow(render_shapes(make_shape(np.arange(5) / 5)))
None</code></pre>
<figure>
<img src="fullblog_files/fullblog_105_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>And then just a check that we can render for all transforms.</p>
<pre class="python"><code>@jax.jit
def im(t):
    s = shape.center_xy().rotate_by(t).translate(50, 50)
    return render_shape(blank, s)[0]


os.system(&quot;rm /tmp/test*.png 2&gt; /dev/null&quot;)
for t in range(T):
    plt.imshow(im(t / T))
    plt.savefig(f&quot;/tmp/test.{t:02d}.png&quot;)
    plt.clf()

animate_out(sorted(glob.glob(&quot;/tmp/test.*.png&quot;)))</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.74.gif" id='ff74'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff74'  
});
</script>
<pre><code>&lt;Figure size 640x480 with 0 Axes&gt;</code></pre>
<p>Now we can do our end-to-end optimization. We need to specify a goal target image, and then render our own guess. Here we start with a blue image and target an orange one. We then optimize through the process to find the color.</p>
<pre class="python"><code>goal = render_shape(blank, shape)[0]

def make_shape(color):
    return shape.fill_color(color)

def loss(x):
    y = render_shape(blank, x)[0]
    return np.pow(y - goal, 2).sum(), ((hgrid + x) | (hgrid + shape)).layout(500)

opt(to_color(&quot;blue&quot;), lambda x: loss(make_shape(x)), rate=0.1)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.75.gif" id='ff75'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff75'  
});
</script>
<h2 id="section-5-differentiable-rasterization">Section 5: Differentiable Rasterization</h2>
<p>Changing the color is neat, but unfortunately if the images didn’t line up exactly things go wrong. The problem is that a key step in our rasterization has a derivative of zero. Take a look at the <code>render_line</code> code and see if you can spot it.</p>
<pre class="python"><code>new_shape = shape.translate(15, 35)
goal = render_shape(blank, new_shape)[0]


def make_shape(color):
    return shape.fill_color(color)


def loss(x):
    y = render_shape(blank, x)[0]
    return np.pow(y - goal, 2).sum(), ((hgrid + x) | (hgrid + new_shape)).layout(500)


opt(to_color(&quot;orange&quot;), lambda x: loss(make_shape(x)), rate=0.1)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.76.gif" id='ff76'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff76'  
});
</script>
<p>The problem is that we are never sending a derivative back through the <code>split</code> variable to the traces, i.e. <span class="math inline">\(\frac{d {\cal L}}{d \ \text{trace}}=0\)</span> That is because the only way split is used is as a discrete index into the array.</p>
<p>There isn’t an trivial way to fix this through scan. The trick instead is to take advantage of the anti-aliasing step. Recall the formula for applying the kernel.</p>
<p><span class="math display">\[I(x) = \int k(u) f(x- u) du\]</span></p>
<p>We would like to take the derivative of this function with respect to the trace.</p>
<p><span class="math display">\[\frac{d}{d \ \text{trace}} \int k(u) f(x- u) du\]</span></p>
<p>But where is the trace in this function? We can think about it as partitioning the integral into <em>inside</em> and <em>outside</em> parts. We call each of these regions <span class="math inline">\(A_i\)</span>.</p>
<p><span class="math display">\[\sum_i \frac{d}{d \ \text{trace}} \int_{A_i} f(x-u) k(u) du\]</span></p>
<p>The trace does impact <span class="math inline">\(k\)</span> only the boundary of the integral. To optimize positioning we need a signal from this boundary position. The methodology for differentiating through integral boundaries is a standard identity called Leibniz’s integral rule.</p>
<p><span class="math display">\[\frac{d}{db} \int_{0}^{b} z(t) dt = z(b) + \int_{0}^{b} \frac{d z(x)}{d b} dx\]</span></p>
<p>The second part is the integral with a path. We have taken care of the already just naturally through our convolution above. The first part though we need to handle ourselves. For our simplified problem this takes a nice form.</p>
<p><span class="math display">\[f(x-\text{split}) k(\text{split}) \approx (f(x-\text{split} + \epsilon) - f(x-\text{split} - \epsilon))k(\text{split})\]</span></p>
<p>Where the approximation is necessary because by definition <span class="math inline">\(f(x - \text{split})\)</span> falls on a boundary point. Intuitively the math is just telling us to move boundaries closer/farther to targets proportional to their kernel value.</p>
<p>Here’s how to implement this in Jax.</p>
<pre class="python"><code>@jax.custom_vjp
def boundary(scene, splits, mask):
    &quot;Do nothing on the forward pass.&quot;
    return scene


def f_fwd(scene, splits, mask):
    &quot;Blank forward pass.&quot;
    return scene, (scene, splits, mask)


def f_bwd(res, g):
    &quot;Backwards pass applies Leibniz.&quot;
    f, splits, mask = res
    split_int = np.floor(splits).astype(int)

    def grad_p(s, s_off):
        &quot;Compute the kernel values of neights around this point&quot;
        off = s_off - s
        # Chain rule part.
        v = g[s + samples]
        return (v * (f[s + 1] - f[s - 1])).sum(-1) @ kernel(off)

    # For each split.
    r = jax.vmap(grad_p, in_axes=(-1, -1))(split_int, splits) * mask
    return g, -r, None

boundary.defvjp(f_fwd, f_bwd)</code></pre>
<p>We then can apply it on top of our rendering function. The idea is that this should not change the image in any way, but it allows us to correct the derivative.</p>
<pre class="python"><code>@jax.jit
def boundary_shape(img, s):
    S = np.arange(SIZE)
    trace = s.get_trace()

    def bound(img, d):
        pt, v = d
        s, m = jax.vmap(lambda i: trace(tx.to_point(pt * i), v))(S)
        bound = lambda s, m: jax.vmap(lambda s, m, im: boundary(im, s, m))(s, m, img)
        img = bound(s, m)
        return np.swapaxes(img, 0, 1), None

    return jax.lax.scan(bound, img, directions)[0], None


def boundaries(img, shapes):
    return jax.lax.scan(boundary_shape, img, shapes)[0]</code></pre>
<p>So now we can try it out.</p>
<pre class="python"><code>
@jax.vmap
def make_shape1(p):
    loc, color = p
    return (
        shape.center_xy().rotate_by(1 / 4).translate(loc[0], loc[1]).fill_color(color)
    )


# Target vector / raster images
goal_shapes = make_shape1(
    (np.array([[50, 40], [40, 50]]), np.stack([to_color(&quot;blue&quot;), to_color(&quot;orange&quot;)]))
)

# Target vector / raster images
goal_shapes = make_shape1(
    (np.array([[50, 40], [40, 50]]), np.stack([to_color(&quot;blue&quot;), to_color(&quot;orange&quot;)]))
)
goal = render_shapes(goal_shapes)

# Initial parameters $x$
start_param = (
    np.array([[60, 30], [60.0, 60.0]]),
    np.stack([to_color(&quot;green&quot;), to_color(&quot;green&quot;)]),
)


# L2 Loss and draw
def loss(goal, goal_shapes, x):
    y = render_shapes(x)
    y = boundaries(y, x)
    return np.pow(y - goal, 2).sum(), (
        bgrid
        + concat(x).with_envelope(empty())
        + concat(goal_shapes).with_envelope(empty()).fill_opacity(0.2)
    ).layout(500)


opt(
    start_param,
    lambda x: loss(goal, goal_shapes, make_shape1(x)),
    steps=500,
    save_every=5,
    rate=0.1,
)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.77.gif" id='ff77'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff77'  
});
</script>
<p>Here’s a more complex example where we draw a blob shape and let it fill in. In Jax you can vmap over any sort of tree structure.</p>
<pre class="python"><code>@jax.vmap
def make_shape2(params):
    s, l, r = params
    s = np.where(np.abs(s) &lt; 1e-3, 1e-3, s)
    part1 = arc_seg(unit_x, s[0])
    part2 = arc_seg(unit_y, s[1])
    part3 = arc_seg(-unit_x, s[2])
    part4 = arc_seg(-unit_y, s[3])
    d = (part1 + part2 + part3 + part4).close().stroke()
    shape = d.scale(12 + r[0]).rotate(70)
    return shape.center_xy().rotate_by(0).translate(50, 30).fill_color(&quot;blue&quot;)


goal_params = (
    np.array([[0.5, 0.2, 0.7, -0.9]]),
    np.array([[50.0, 30]]),
    np.array([[5.0]]),
)
goal_shapes = make_shape2(goal_params)
goal = render_shapes(goal_shapes)
start_param = (np.array([[-0.5, 0.1, 2, 1]]), np.array([[50.0, 30]]), np.array([[0.0]]))

opt(
    start_param,
    lambda x: loss(goal, goal_shapes, make_shape2(x)),
    steps=1000,
    save_every=5,
    rate=0.01,
)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.78.gif" id='ff78'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff78'  
});
</script>
<p>In this example we create a bunch or red and blue circles and then try to fill them in.</p>
<pre class="python"><code>import random


@jax.vmap
def make_shape3(params, i):
    s, l = params
    s = np.minimum(np.maximum(s, 5.0), 15)
    red, blue = to_color(&quot;red&quot;), to_color(&quot;blue&quot;)
    return (
        circle_at(tx.X.origin, s)
        .translate(l[0], l[1])
        .fill_color(np.where(i % 2, red, blue))
    )



make_shape3 = partial(make_shape3, i=np.arange(10.0))

goal_param = (
    np.array([10 + random.random() for i in range(10)]),
    np.array([20 + random.random() * 50 for i in range(20)]).reshape(10, 2),
)
goal_shapes = make_shape3(goal_param)

make_shape3 = partial(make_shape3, i=np.arange(20))

goal = render_shapes(goal_shapes)
start_param = (
    np.array([10 + random.random() for i in range(20)]),
    np.array([20 + 50 * random.random() for i in range(40)], np.float64).reshape(20, 2),
)


opt(
    start_param,
    lambda x: loss(goal, goal_shapes, make_shape3(x)),
    steps=1000,
    save_every=5,
    rate=0.1,
)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.79.gif" id='ff79'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff79'  
});
</script>
<p>We can also test out shapes the multiple in and out parts likes a star.</p>
<pre class="python"><code> @jax.vmap
 def star(x):
     sides = 5
     edge = Trail.hrule(1)
     return Trail.concat(
        edge.rotate_by((2 * i) / sides) for i in range(sides)
     ).close().stroke().center_xy().scale(x[0]).rotate_by(x[1]).translate(x[2], x[3] ).fill_color(&quot;orange&quot;)
random.seed(1)

start_param = np.array([[35.,random.random(),  40 + i * 20, 40 + 20 * j] for i in range(1) for j in range(1)])
g = np.array([[35., random.random(), 40 + i * 20, 40 + 20 * j] for i in range(1) for j in range(1)])
goal_shapes = star(g)
goal = render_shapes(star(g))
 
opt(
    start_param,
    lambda x: loss(goal, goal_shapes, star(x)),
    steps=500,
    save_every=10,
    rate=0.1,
    verbose=False,
)
</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.80.gif" id='ff80'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff80'  
});
</script>
<pre class="python"><code>@jax.vmap
def star(x):
    sides = 5
    edge = Trail.hrule(1)
    return (
        Trail.concat(edge.rotate_by((i) / sides) for i in range(sides))
        .close()
        .stroke()
        .center_xy()
        .scale(15)
        .rotate_by(x[1])
        .translate(25 + x[2], 25 + x[3])
        .fill_color(&quot;orange&quot;)
    )

start_param = np.array(
    [
        [15.0, random.random(), 5 + i * 20, 10 + 20 * j]
        for i in range(3)
        for j in range(3)
    ]
)
g = np.array(
    [
        [15.0, random.random(), 1 + i * 20, 1 + 20 * j]
        for i in range(3)
        for j in range(3)
    ]
)
goal_shapes = star(g)
goal = render_shapes(star(g))

opt(
    start_param,
    lambda x: loss(goal, goal_shapes, star(x)),
    steps=500,
    save_every=2,
    rate=0.05,
    verbose=False,
)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.81.gif" id='ff81'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff81'  
});
</script>
<p>All this work brings us to our final goal, rendering an actual image. Here we take an image from the web and convert it to an array. Then we start with a bunch of ellipses (scale-transformed circles) and see how well they can do to approximate it. Results are pretty neat!</p>
<p>Grab an image from the web and covert to RGB.</p>
<pre class="python"><code>goal = pix

# Draw a bunch of circles.
# Parameterize by scale, translation, and roation.
@jax.vmap
def make_smiley(p):
    s, l, r, c, rot = p
    s = np.where(np.abs(s) &lt; 1e-3, (np.abs(s) / s) * 1e-3, s)
    d = circle_at(P2(0, 0), 1).center_xy()
    r = np.where(np.abs(r) &lt; 1e-3, 0.1, (np.abs(r) / r) * r)
    return (
        d.rotate(rot)
        .scale(1)
        .scale_x((r[0]))
        .scale_y((r[1]))
        .translate(l[0], l[1])
        .fill_color(jax.nn.sigmoid(c))
    )


random.seed(1)

# Draw 20 circles with random starting
# values.
n = 20
start_param = (
    np.zeros((n, 4)) + 0.1,
    np.array(
        [[20 + 60 * random.random(), 20 + 60 * random.random()] for i in range(n)]
    ),
    np.ones((n, 2)) + 2 * np.arange(n + 1, 1, -1)[:, None],
    np.ones((n, 3)),
    np.zeros((n, 1)),
)


# Reduce color precision of the goal slightly.
def reduce(y):
    return np.floor(y * 40) / 40


def loss(goal, x):
    y = render_shapes(x)
    y = boundaries(y, x)
    return np.pow(y - reduce(goal), 2).sum(), None


@jax.jit
def show(x):
    return (bgrid + concat(make_smiley(x)).with_envelope(empty()).line_width(0)).layout(
        500
    )


# Optimize!
opt(
    start_param,
    lambda x: loss(goal, make_smiley(x)),
    show=show,
    steps=1000,
    save_every=10,
    rate=0.1,
)</code></pre>
<div style="text-align:center;">
<div style="width:70%; margin:auto;">
<img src="out.82.gif" id='ff82'>
</div>
</div>
<script>
new Freezeframe({
  selector: '#ff82'  
});
</script>
<h2 id="conclusion">Conclusion</h2>
<p>So the goal of this post was to understand what differentiable programming really look like for challening problems. Of course graphics is a particularly nice area for this kind of silliness. Since everything has a nice and well-defined mathematical form, with enough work we can push through the necessary gradients. We only really had to use one major trick to make derivative work, other wise it was just converting if’s and for’s to np.where and vmap.</p>
<p>Still I think this sort of method is still really underexplored in other areas. We have really nice tools for writing very complex programs in a fully vectorized way, and yet we aren’t really doing it yet as much as feels possible. I hope I can convince you that while a little scary, this kind of programming is pretty powerful and realistically accessible for a lot of different domains.</p>
<p>-Sasha</p>
</body>
</html>
